#' Create an interactive Shiny app for visualization & exploration of MAGeCK RRA CRISPR analyses
#'
#' This shiny app is composed of multiple tabs to peruse RRA results and compare them between timepoints or samples.
#' Also included are numerous QC plots. Almost all plots are interactive and their aesthetics can be easily tweaked
#' using the sidebar. See the Details section for more information.
#'
#' Gene labels can be added to the MAplot and volcano plot by clicking a point. The labels can also be dragged around,
#' though adding labels will reset the positions, so it's recommended to add all labels prior to re-positioning them.
#'
#' @details Features with no variation will be removed prior to \code{\link[PCAtools]{pca}} being run for the PCA visualization.
#'
#' @param gene.data A named list containing \code{gene_summary.txt} tables as data.frames.
#'   Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{sgrna.data} list elements.
#' @param sgrna.data A named list containing \code{sgrna_summary.txt} tables as data.frames.
#'   Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{gene.data} list elements.
#' @param count.summary Matrix or dataframe containing count summary (\code{countsummary.txt}) as generated by \code{mageck count}.
#' @param norm.counts Matrix or dataframe containing normalized counts (\code{count_normalized.txt}) as generated by \code{mageck count}.
#' @param h.id String indicating unique ID for interactive plots.
#'   Required if multiple apps are run within the same Rmd file.
#' @param positive.ctrl.genes Optional character vector of gene identifiers for
#'   positive control genes from the screen so that they can be easily filtered.
#' @param essential.genes Optional character vector of gene identifiers of common
#'   essential genes (i.e. pan-lethal) so that they can be easily filtered.
#'   If provided, overrides the depmap essential genes.
#' @param depmap.db Optional character scalar for name of SQLite database returned by \code{\link{build_depmap_db}}.
#' @param genesets Optional named list containing genesets that can be interactively highlighted on the plots.
#'   The elements of the list should each be a geneset with gene identifiers matching those used in the results.
#' @param return.app Optional boolean indicating whether a Shiny app should be returned. \code{TRUE} by default. If \code{FALSE},
#'   a named list of app elements (ui and server) will be returned instead. Useful for deploying as a standalone shiny app.
#'
#' @return A Shiny app containing interactive visualizations of MAGeCK RRA analysis results.
#'
#' @rawNamespace import(shiny, except = c(dataTableOutput, renderDataTable))
#' @importFrom ComplexHeatmap Heatmap pheatmap make_comb_mat extract_comb set_name comb_name UpSet draw
#' @importFrom InteractiveComplexHeatmap InteractiveComplexHeatmapOutput makeInteractiveComplexHeatmap
#' @import DT
#' @importFrom plotly ggplotly plotlyOutput renderPlotly toWebGL plot_ly layout add_annotations add_segments config toRGB event_data add_trace style
#' @import ggplot2
#' @importFrom shinyWidgets prettyCheckbox dropdownButton tooltipOptions pickerInput updatePickerInput
#' @importFrom shinycssloaders withSpinner
#' @importFrom shinyjqui jqui_resizable
#' @importFrom shinyjs show useShinyjs hidden disable click extendShinyjs js
#' @importFrom shinyBS tipify popify bsCollapse bsCollapsePanel
#' @importFrom colourpicker colourInput
#' @importFrom dittoSeq dittoColors
#' @importFrom grid grid.newpage grid.text
#' @importFrom stats cor as.formula
#' @importFrom utils read.csv read.delim
#'
#' @author Jared Andrews
#' @export
CRISPRball <- function(gene.data = NULL, sgrna.data = NULL, count.summary = NULL, norm.counts = NULL, h.id = "mag1",
                       positive.ctrl.genes = NULL, essential.genes = NULL,
                       depmap.db = NULL, genesets = NULL, return.app = TRUE) {
  # Increase file upload size limit to 50MB, which should cover pretty much any use case.
  options(shiny.maxRequestSize = 50 * 1024^2)

  # Set initial metadata and dataset choices if input data isn't NULL.
  gene.choices <- NULL
  sgrna.choices <- NULL
  summ.choices <- NULL
  sgrna.gene <- NULL

  default.tab <- NULL

  if (!is.null(gene.data)) {
    gene.choices <- names(gene.data)
  }

  if (!is.null(sgrna.data)) {
    sgrna.choices <- names(sgrna.data)
    sgrna.gene <- unique(c(sgrna.data[[1]]$Gene))
  }

  if (!is.null(count.summary)) {
    summ.choices <- colnames(count.summary)
    default.tab <- "QC"
  }

  # Load cell line metadata and gene summaries if depmap db provided.
  if (!is.null(depmap.db)) {
    .error_if_no_pool()
    .error_if_no_rsqlite()

    pool <- pool::dbPool(RSQLite::SQLite(), dbname = depmap.db)
    depmap.meta <- pool::dbGetQuery(pool, "SELECT * FROM 'meta'")
    depmap.gene <- pool::dbGetQuery(pool, "SELECT * FROM 'gene.summary'")

    # Close db on app close.
    onStop(function() {
      pool::poolClose(pool)
    })
  } else {
    depmap.meta <- NULL
    depmap.gene <- NULL
  }

  ui <- navbarPage(
    "CRISPRball",
    selected = default.tab,
    useShinyjs(),
    extendShinyjs(text = .utils.js, functions = c("disableTab", "enableTab")),
    css,
    # ---------------Data Upload-----------------
    tab_data_upload,
    # ----------------QC--------------------
    .create_tab_qc(summ.choices),
    # -------------------QC Table----------------
    tabPanel(
      title = "QC Table",
      id = "qc-table",
      br(),
      DTOutput("count.summary")
    ),
    # ------------------Gene (Overview)-------------
    .create_tab_gene(gene.choices, genesets),
    # ----------------Gene Summary Tables--------------
    tab_gene_summary,
    # ----------------sgRNA---------------------
    .create_tab_sgrna(sgrna.choices, sgrna.gene),
    # --------------------sgRNA Summary Tables----------------
    tab_sgrna_summary,
    # --------------------Dataset Comparisons----------------
    .create_tab_comparison(gene.choices),
    # -----------------DepMap-------------------
    .create_tab_depmap(sgrna.data, depmap.meta),
    # -----------------About-------------------
    tab_about
  )

  server <- function(input, output, session) {
    # --------------Disable Tabs-----------------
    defaultDisabledTabs <- c()

    if (is.null(gene.data)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "Gene (Overview)", "Gene Summary Tables")
    }

    if (length(gene.data) < 2) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "Dataset Comparisons")
    }

    if (is.null(sgrna.data)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "sgRNA", "sgRNA Summary Tables")
    }

    if (is.null(count.summary) | is.null(norm.counts)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "QC", "QC Table")
    }

    for (tabname in defaultDisabledTabs) {
      js$disableTab(tabname)
    }

    # --------------Disable Inputs-----------------
    # Disable certain inputs if no data is provided.
    if (is.null(depmap.gene)) {
      shinyjs::hide("dep.crispr.ess")
      shinyjs::hide("dep.crispr.sel")
      shinyjs::hide("dep.rnai.ess")
      shinyjs::hide("dep.rnai.sel")

      shinyjs::hide("comp.dep.crispr.ess")
      shinyjs::hide("comp.dep.crispr.sel")
      shinyjs::hide("comp.dep.rnai.ess")
      shinyjs::hide("comp.dep.rnai.sel")
    }

    if (is.null(essential.genes)) {
      shinyjs::hide("rem.ess")
      shinyjs::hide("comp.rem.ess")
    }

    if (is.null(positive.ctrl.genes)) {
      shinyjs::hide("rem.pos")
      shinyjs::hide("comp.rem.pos")
    }

    # Disable certain inputs if only one dataset provided.
    observe({
      if (length(robjects$gene.data) == 1) {
        shinyjs::disable("gene.sel2")
        shinyjs::hide("highlight.common")
      }
    })

    # -------------Reactive Values---------------

    robjects <- reactiveValues(
      gene.data = gene.data, sgrna.data = sgrna.data,
      count.summary = count.summary, norm.counts = norm.counts,
      depmap.meta = depmap.meta, depmap.gene = depmap.gene,
      clicked = list(
        volc1 = NULL, rank1 = NULL, lawn1 = NULL,
        volc2 = NULL, rank2 = NULL, lawn2 = NULL
      ),
      comps = list(), comp.neg.genes = list(), comp.pos.genes = list(),
      positive.ctrl.genes = positive.ctrl.genes, essential.genes = essential.genes,
      genesets = genesets, pc = NULL, h.id = h.id
    )

    # ---------------Data Upload-----------------
    # Create data upload observers.
    .create_upload_observers(input, session, robjects)

    # Hide depmap tab if database not provided.
    # Tried disable, still looks/feels selectable which may be confusing.
    if (is.null(depmap.db)) {
      shinyjs::hide(selector = '.navbar-nav a[data-value="DepMap"')
    }


    # -----------QC & QC Summary Tabs------------
    # PCA.
    .create_qc_observers(input, robjects)

    .create_qc_output(input, output, robjects)

    # Initialize plots by simulating button click once.
    o <- observe({
      req(robjects$pca.mat, robjects$pca.meta)
      shinyjs::click("pca.update")
      o$destroy
    })

    #---------Gene (Overview) & Summary Tables Tabs-------------

    # Load the gene summaries for easy plotting.
    .create_gene_observers(input, robjects)

    # Summary table and plots.
    output$gene1.summary <- renderDT(server = FALSE, {
      req(robjects$set1.genes)
      # Remove columns that are redundant or confusing.
      target <- which(names(robjects$set1.genes) %in% c(
        "neg|score", "neg|p-value", "neg|rank",
        "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
        "pos|lfc", "RandomIndex", "Rank", "goodsgrna"
      )) - 1

      df <- robjects$set1.genes

      if (!is.null(robjects$common.hits)) {
        df$Overlap <- df$id %in% robjects$common.hits
      }

      DT::datatable(df,
        rownames = FALSE,
        filter = "top",
        extensions = c("Buttons"),
        caption = paste0(input$gene.sel1, " Gene Summary"),
        options = list(
          search = list(regex = TRUE),
          pageLength = 10,
          dom = "Blfrtip",
          buttons = c("copy", "csv", "excel", "pdf", "print"),
          columnDefs = list(list(visible = FALSE, targets = target))
        )
      ) %>% DT::formatStyle(0, target = "row", lineHeight = "50%")
    })

    output$gene1.vol <- renderPlotly({
      req(robjects$set1.genes)
      input$vol.update

      df <- robjects$set1.genes

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential, ]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control, ]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential, ]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective, ]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential, ]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective, ]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(isolate(input$hl.genes), ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(robjects$common.hits, highlight))
      }


      .make_volcano(
        res = df,
        xlim = isolate(input$vol.x),
        ylim = isolate(input$vol.y),
        fc.thresh = isolate(input$gene.lfc.th),
        fc.lines = isolate(input$vol.fcline),
        sig.thresh = isolate(input$gene.fdr.th),
        sig.line = isolate(input$vol.sigline),
        h.id = h.id,
        h.id.suffix = "_volc1",
        sig.term = "FDR",
        lfc.term = "LFC",
        feat.term = "id",
        hover.info = hov.info,
        fs = robjects$clicked$volc1,
        up.color = isolate(input$up.color),
        down.color = isolate(input$down.color),
        insig.color = isolate(input$insig.color),
        sig.opacity = isolate(input$sig.opa),
        insig.opacity = isolate(input$insig.opa),
        sig.size = isolate(input$sig.size),
        insig.size = isolate(input$insig.size),
        label.size = isolate(input$lab.size),
        webgl = isolate(input$webgl),
        webgl.ratio = isolate(input$webgl.ratio),
        show.counts = isolate(input$counts),
        show.hl.counts = isolate(input$hl.counts),
        counts.size = isolate(input$counts.size),
        highlight.featsets = isolate(input$hl.genesets),
        highlight.feats = highlight,
        featsets = genesets,
        highlight.feats.color = isolate(input$hl.genes.col),
        highlight.feats.size = isolate(input$hl.genes.size),
        highlight.feats.opac = isolate(input$hl.genes.opa),
        highlight.feats.linecolor = isolate(input$hl.genes.lcol),
        highlight.feats.linewidth = isolate(input$hl.genes.lw),
        highlight.featsets.color = isolate(input$hl.genesets.col),
        highlight.featsets.size = isolate(input$hl.genesets.size),
        highlight.featsets.opac = isolate(input$hl.genesets.opa),
        highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
        highlight.featsets.linewidth = isolate(input$hl.genesets.lw)
      )
    })

    output$gene1.rank <- renderPlotly({
      req(robjects$set1.genes)
      input$rank.update

      df <- robjects$set1.genes

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential, ]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control, ]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential, ]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective, ]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential, ]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective, ]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(isolate(input$hl.genes), ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(robjects$common.hits, highlight))
      }

      .make_rank(
        df = df,
        ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
        y.thresh = isolate(input$gene.lfc.th),
        y.lines = isolate(input$rank.fcline),
        sig.thresh = isolate(input$gene.fdr.th),
        h.id = h.id,
        h.id.suffix = "_rank1",
        sig.term = "FDR",
        y.term = "LFC",
        x.term = "Rank",
        feat.term = "id",
        hover.info = c("hit_type", "goodsgrna"),
        fs = robjects$clicked$rank1,
        up.color = isolate(input$up.color),
        down.color = isolate(input$down.color),
        insig.color = isolate(input$insig.color),
        sig.opacity = isolate(input$sig.opa),
        insig.opacity = isolate(input$insig.opa),
        sig.size = isolate(input$sig.size),
        insig.size = isolate(input$insig.size),
        label.size = isolate(input$lab.size),
        webgl = isolate(input$webgl),
        webgl.ratio = isolate(input$webgl.ratio),
        show.counts = isolate(input$counts),
        show.hl.counts = isolate(input$hl.counts),
        counts.size = isolate(input$counts.size),
        highlight.featsets = isolate(input$hl.genesets),
        highlight.feats = highlight,
        featsets = genesets,
        highlight.feats.color = isolate(input$hl.genes.col),
        highlight.feats.size = isolate(input$hl.genes.size),
        highlight.feats.opac = isolate(input$hl.genes.opa),
        highlight.feats.linecolor = isolate(input$hl.genes.lcol),
        highlight.feats.linewidth = isolate(input$hl.genes.lw),
        highlight.featsets.color = isolate(input$hl.genesets.col),
        highlight.featsets.size = isolate(input$hl.genesets.size),
        highlight.featsets.opac = isolate(input$hl.genesets.opa),
        highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
        highlight.featsets.linewidth = isolate(input$hl.genesets.lw)
      )
    })

    output$gene1.lawn <- renderPlotly({
      req(robjects$set1.genes)
      df <- robjects$set1.genes
      input$lawn.update

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential, ]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control, ]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential, ]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective, ]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential, ]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective, ]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(isolate(input$hl.genes), ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(robjects$common.hits, highlight))
      }

      .make_lawn(
        res = df,
        ylim = isolate(input$lawn.y),
        fc.thresh = isolate(input$gene.lfc.th),
        sig.thresh = isolate(input$gene.fdr.th),
        sig.line = isolate(input$lawn.sigline),
        h.id = h.id,
        h.id.suffix = "_lawn1",
        sig.term = "FDR",
        lfc.term = "LFC",
        feat.term = "id",
        x.term = "RandomIndex",
        hover.info = hov.info,
        fs = robjects$clicked$lawn1,
        up.color = isolate(input$up.color),
        down.color = isolate(input$down.color),
        insig.color = isolate(input$insig.color),
        sig.opacity = isolate(input$sig.opa),
        insig.opacity = isolate(input$insig.opa),
        sig.size = isolate(input$sig.size),
        insig.size = isolate(input$insig.size),
        label.size = isolate(input$lab.size),
        webgl = isolate(input$webgl),
        webgl.ratio = isolate(input$webgl.ratio),
        show.counts = isolate(input$counts),
        show.hl.counts = isolate(input$hl.counts),
        counts.size = isolate(input$counts.size),
        highlight.featsets = isolate(input$hl.genesets),
        highlight.feats = highlight,
        featsets = genesets,
        highlight.feats.color = isolate(input$hl.genes.col),
        highlight.feats.size = isolate(input$hl.genes.size),
        highlight.feats.opac = isolate(input$hl.genes.opa),
        highlight.feats.linecolor = isolate(input$hl.genes.lcol),
        highlight.feats.linewidth = isolate(input$hl.genes.lw),
        highlight.featsets.color = isolate(input$hl.genesets.col),
        highlight.featsets.size = isolate(input$hl.genesets.size),
        highlight.featsets.opac = isolate(input$hl.genesets.opa),
        highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
        highlight.featsets.linewidth = isolate(input$hl.genesets.lw)
      )
    })

    # If only one dataset provided, don't render second dataset.
    observe({
      if (length(robjects$gene.data) > 1) {
        output$gene2.summary <- renderDT(server = FALSE, {
          req(robjects$set2.genes)
          df <- robjects$set2.genes

          # Remove columns that are redundant or confusing.
          target <- which(names(robjects$set2.genes) %in% c(
            "neg|score", "neg|p-value", "neg|rank",
            "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
            "pos|lfc", "RandomIndex", "Rank", "goodsgrna"
          )) - 1

          # Label overlapping hits between datasets if available.
          if (!is.null(robjects$common.hits)) {
            df$Overlap <- df$id %in% robjects$common.hits
          }

          DT::datatable(df,
            rownames = FALSE,
            filter = "top",
            extensions = c("Buttons"),
            caption = paste0(input$gene.sel2, " Gene Summary"),
            options = list(
              search = list(regex = TRUE),
              dom = "Blfrtip",
              buttons = c("copy", "csv", "excel", "pdf", "print"),
              pageLength = 10,
              columnDefs = list(list(visible = FALSE, targets = target))
            )
          ) %>% DT::formatStyle(0, target = "row", lineHeight = "50%")
        })

        output$gene2.vol <- renderPlotly({
          req(robjects$set2.genes)
          input$vol.update

          df <- robjects$set2.genes

          hov.info <- c("hit_type", "num", "goodsgrna")

          # Remove common essential genes if needed.
          if (isolate(input$rem.ess) & !is.null(df$essential)) {
            df <- df[!df$essential, ]
          }

          # Remove positive control genes if needed.
          if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
            df <- df[!df$Positive_Control, ]
          }

          # Remove DepMap stuff if requested.
          if (!is.null(depmap.gene)) {
            if (isolate(input$dep.crispr.ess)) {
              df <- df[!df$DepMap_CRISPR_Essential, ]
            }

            if (isolate(input$dep.crispr.sel)) {
              df <- df[!df$DepMap_CRISPR_Selective, ]
            }

            if (isolate(input$dep.rnai.ess)) {
              df <- df[!df$DepMap_RNAi_Essential, ]
            }

            if (isolate(input$dep.rnai.sel)) {
              df <- df[!df$DepMap_RNAi_Selective, ]
            }
          }

          highlight <- NULL
          if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
            highlight.feats <- strsplit(isolate(input$hl.genes), ",|\\s|,\\s")[[1]]
            highlight <- highlight.feats[highlight.feats != ""]
          }

          # Add common hits to highlight.
          if (isolate(input$highlight.common)) {
            highlight <- unique(c(robjects$common.hits, highlight))
          }


          .make_volcano(
            res = df,
            xlim = isolate(input$vol.x),
            ylim = isolate(input$vol.y),
            fc.thresh = isolate(input$gene.lfc.th),
            fc.lines = isolate(input$vol.fcline),
            sig.thresh = isolate(input$gene.fdr.th),
            sig.line = isolate(input$vol.sigline),
            h.id = h.id,
            h.id.suffix = "_volc2",
            sig.term = "FDR",
            lfc.term = "LFC",
            feat.term = "id",
            hover.info = hov.info,
            fs = robjects$clicked$volc2,
            up.color = isolate(input$up.color),
            down.color = isolate(input$down.color),
            insig.color = isolate(input$insig.color),
            sig.opacity = isolate(input$sig.opa),
            insig.opacity = isolate(input$insig.opa),
            sig.size = isolate(input$sig.size),
            insig.size = isolate(input$insig.size),
            label.size = isolate(input$lab.size),
            webgl = isolate(input$webgl),
            webgl.ratio = isolate(input$webgl.ratio),
            show.counts = isolate(input$counts),
            show.hl.counts = isolate(input$hl.counts),
            counts.size = isolate(input$counts.size),
            highlight.featsets = isolate(input$hl.genesets),
            highlight.feats = highlight,
            featsets = genesets,
            highlight.feats.color = isolate(input$hl.genes.col),
            highlight.feats.size = isolate(input$hl.genes.size),
            highlight.feats.opac = isolate(input$hl.genes.opa),
            highlight.feats.linecolor = isolate(input$hl.genes.lcol),
            highlight.feats.linewidth = isolate(input$hl.genes.lw),
            highlight.featsets.color = isolate(input$hl.genesets.col),
            highlight.featsets.size = isolate(input$hl.genesets.size),
            highlight.featsets.opac = isolate(input$hl.genesets.opa),
            highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
            highlight.featsets.linewidth = isolate(input$hl.genesets.lw)
          )
        })

        output$gene2.rank <- renderPlotly({
          req(robjects$set2.genes)
          input$rank.update

          hov.info <- c("hit_type", "num", "goodsgrna")

          df <- robjects$set2.genes

          # Remove common essential genes if needed.
          if (isolate(input$rem.ess) & !is.null(df$essential)) {
            df <- df[!df$essential, ]
          }

          # Remove positive control genes if needed.
          if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
            df <- df[!df$Positive_Control, ]
          }

          # Remove DepMap stuff if requested.
          if (!is.null(depmap.gene)) {
            if (isolate(input$dep.crispr.ess)) {
              df <- df[!df$DepMap_CRISPR_Essential, ]
            }

            if (isolate(input$dep.crispr.sel)) {
              df <- df[!df$DepMap_CRISPR_Selective, ]
            }

            if (isolate(input$dep.rnai.ess)) {
              df <- df[!df$DepMap_RNAi_Essential, ]
            }

            if (isolate(input$dep.rnai.sel)) {
              df <- df[!df$DepMap_RNAi_Selective, ]
            }
          }

          highlight <- NULL
          if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
            highlight.feats <- strsplit(isolate(input$hl.genes), ",|\\s|,\\s")[[1]]
            highlight <- highlight.feats[highlight.feats != ""]
          }

          # Add common hits to highlight.
          if (isolate(input$highlight.common)) {
            highlight <- unique(c(robjects$common.hits, highlight))
          }

          .make_rank(
            df = df,
            ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
            y.thresh = isolate(input$gene.lfc.th),
            y.lines = isolate(input$rank.fcline),
            sig.thresh = isolate(input$gene.fdr.th),
            h.id = h.id,
            h.id.suffix = "_rank2",
            sig.term = "FDR",
            y.term = "LFC",
            x.term = "Rank",
            feat.term = "id",
            hover.info = hov.info,
            fs = robjects$clicked$rank2,
            up.color = isolate(input$up.color),
            down.color = isolate(input$down.color),
            insig.color = isolate(input$insig.color),
            sig.opacity = isolate(input$sig.opa),
            insig.opacity = isolate(input$insig.opa),
            sig.size = isolate(input$sig.size),
            insig.size = isolate(input$insig.size),
            label.size = isolate(input$lab.size),
            webgl = isolate(input$webgl),
            webgl.ratio = isolate(input$webgl.ratio),
            show.counts = isolate(input$counts),
            show.hl.counts = isolate(input$hl.counts),
            counts.size = isolate(input$counts.size),
            highlight.featsets = isolate(input$hl.genesets),
            highlight.feats = highlight,
            featsets = genesets,
            highlight.feats.color = isolate(input$hl.genes.col),
            highlight.feats.size = isolate(input$hl.genes.size),
            highlight.feats.opac = isolate(input$hl.genes.opa),
            highlight.feats.linecolor = isolate(input$hl.genes.lcol),
            highlight.feats.linewidth = isolate(input$hl.genes.lw),
            highlight.featsets.color = isolate(input$hl.genesets.col),
            highlight.featsets.size = isolate(input$hl.genesets.size),
            highlight.featsets.opac = isolate(input$hl.genesets.opa),
            highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
            highlight.featsets.linewidth = isolate(input$hl.genesets.lw)
          )
        })

        output$gene2.lawn <- renderPlotly({
          req(robjects$set2.genes)
          input$lawn.update

          hov.info <- c("hit_type", "num", "goodsgrna")

          df <- robjects$set2.genes

          # Remove common essential genes if needed.
          if (isolate(input$rem.ess) & !is.null(df$essential)) {
            df <- df[!df$essential, ]
          }

          # Remove positive control genes if needed.
          if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
            df <- df[!df$Positive_Control, ]
          }

          # Remove DepMap stuff if requested.
          if (!is.null(depmap.gene)) {
            if (isolate(input$dep.crispr.ess)) {
              df <- df[!df$DepMap_CRISPR_Essential, ]
            }

            if (isolate(input$dep.crispr.sel)) {
              df <- df[!df$DepMap_CRISPR_Selective, ]
            }

            if (isolate(input$dep.rnai.ess)) {
              df <- df[!df$DepMap_RNAi_Essential, ]
            }

            if (isolate(input$dep.rnai.sel)) {
              df <- df[!df$DepMap_RNAi_Selective, ]
            }
          }

          highlight <- NULL
          if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
            highlight.feats <- strsplit(isolate(input$hl.genes), ",|\\s|,\\s")[[1]]
            highlight <- highlight.feats[highlight.feats != ""]
          }

          # Add common hits to highlight.
          if (isolate(input$highlight.common)) {
            highlight <- unique(c(robjects$common.hits, highlight))
          }

          .make_lawn(
            res = df,
            ylim = isolate(input$lawn.y),
            fc.thresh = isolate(input$gene.lfc.th),
            sig.thresh = isolate(input$gene.fdr.th),
            sig.line = isolate(input$lawn.sigline),
            h.id = h.id,
            h.id.suffix = "_lawn2",
            sig.term = "FDR",
            lfc.term = "LFC",
            feat.term = "id",
            x.term = "RandomIndex",
            hover.info = hov.info,
            fs = robjects$clicked$lawn2,
            up.color = isolate(input$up.color),
            down.color = isolate(input$down.color),
            insig.color = isolate(input$insig.color),
            sig.opacity = isolate(input$sig.opa),
            insig.opacity = isolate(input$insig.opa),
            sig.size = isolate(input$sig.size),
            insig.size = isolate(input$insig.size),
            label.size = isolate(input$lab.size),
            webgl = isolate(input$webgl),
            webgl.ratio = isolate(input$webgl.ratio),
            show.counts = isolate(input$counts),
            show.hl.counts = isolate(input$hl.counts),
            counts.size = isolate(input$counts.size),
            highlight.featsets = isolate(input$hl.genesets),
            highlight.feats = highlight,
            featsets = genesets,
            highlight.feats.color = isolate(input$hl.genes.col),
            highlight.feats.size = isolate(input$hl.genes.size),
            highlight.feats.opac = isolate(input$hl.genes.opa),
            highlight.feats.linecolor = isolate(input$hl.genes.lcol),
            highlight.feats.linewidth = isolate(input$hl.genes.lw),
            highlight.featsets.color = isolate(input$hl.genesets.col),
            highlight.featsets.size = isolate(input$hl.genesets.size),
            highlight.featsets.opac = isolate(input$hl.genesets.opa),
            highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
            highlight.featsets.linewidth = isolate(input$hl.genesets.lw)
          )
        })
      }
    })

    # If the Gene tab update button is pressed, click all the update buttons.
    observeEvent(input$gene.update, {
      shinyjs::click("lawn.update")
      shinyjs::click("vol.update")
      shinyjs::click("rank.update")
    })

    #---------------sgRNA Tab-----------------

    # Load the gene summaries for easy plotting.
    observe({
      df <- robjects$sgrna.data[[input$sgrna.sel1]]
      df$Rank <- rank(df$LFC)
      robjects$set1.sgrnas <- df

      if (length(robjects$sgrna.data) > 1) {
        df <- robjects$sgrna.data[[input$sgrna.sel2]]
        df$Rank <- rank(df$LFC)
        robjects$set2.sgrnas <- df
      }
    })

    # Summary tables and plots.
    output$sgrna1.summary <- renderDT(server = FALSE, {
      req(robjects$set1.sgrnas)

      df <- robjects$set1.sgrnas

      DT::datatable(df,
        rownames = FALSE,
        filter = "top",
        extensions = c("Buttons"),
        caption = paste0(input$sgrna.sel1, " sgRNA Summary"),
        options = list(
          search = list(regex = TRUE),
          pageLength = 10,
          dom = "Blfrtip",
          buttons = c("copy", "csv", "excel", "pdf", "print")
        )
      ) %>% DT::formatStyle(0, target = "row", lineHeight = "50%")
    })

    output$sgrna1.counts <- renderPlotly({
      req(robjects$set1.sgrnas, input$sgrna.gene)

      df <- robjects$set1.sgrnas
      df <- df[df$Gene == input$sgrna.gene, ]

      .make_sgrna_pairplot(df)
    })

    output$sgrna1.rank <- renderPlotly({
      req(robjects$set1.sgrnas)
      input$rank.update

      df <- robjects$set1.sgrnas

      hov.info <- c("Gene")

      highlight <- NULL
      highlight <- df$sgrna[df$Gene == input$sgrna.gene]

      .make_rank(
        df = df,
        ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
        y.thresh = 0,
        y.lines = FALSE,
        sig.thresh = 0,
        h.id = h.id,
        h.id.suffix = "_sgrank1",
        sig.term = "FDR",
        y.term = "LFC",
        x.term = "Rank",
        feat.term = "sgrna",
        hover.info = hov.info,
        fs = NULL,
        up.color = "#A6A6A6",
        down.color = "#A6A6A6",
        insig.color = "#A6A6A6",
        sig.opacity = 1,
        insig.opacity = 1,
        sig.size = 5,
        insig.size = 5,
        label.size = 8,
        webgl = TRUE,
        webgl.ratio = 7,
        show.counts = FALSE,
        show.hl.counts = FALSE,
        counts.size = 8,
        highlight.featsets = NULL,
        highlight.feats = highlight,
        featsets = NULL,
        highlight.feats.color = "red",
        highlight.feats.size = 8,
        highlight.feats.opac = 1,
        highlight.feats.linecolor = "black",
        highlight.feats.linewidth = 0.5,
        highlight.featsets.color = "#A6A6A6",
        highlight.featsets.size = 7,
        highlight.featsets.opac = 1,
        highlight.featsets.linecolor = "black",
        highlight.featsets.linewidth = 0.5
      )
    })

    output$sgrna1.detail <- renderDT({
      req(robjects$set1.sgrnas, input$sgrna.gene)

      df <- robjects$set1.sgrnas
      df <- df[df$Gene == input$sgrna.gene, ]

      target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1

      DT::datatable(df,
        rownames = FALSE,
        filter = "top",
        extensions = c("Buttons"),
        caption = paste0(input$sgrna.sel1, " ", input$sgrna.gene, " sgRNA Details"),
        options = list(
          pageLength = 10,
          dom = "Blfrtip",
          buttons = c("copy", "csv", "excel", "pdf", "print"),
          columnDefs = list(list(visible = FALSE, targets = target))
        )
      ) %>% DT::formatStyle(0, target = "row", lineHeight = "50%")
    })

    observe({
      if (length(robjects$sgrna.data) > 1) {
        output$sgrna2.summary <- renderDT(server = FALSE, {
          req(robjects$set2.sgrnas)

          df <- robjects$set2.sgrnas

          DT::datatable(df,
            rownames = FALSE,
            filter = "top",
            extensions = c("Buttons"),
            caption = paste0(input$sgrna.sel2, " sgRNA Summary"),
            options = list(
              search = list(regex = TRUE),
              pageLength = 10,
              dom = "Blfrtip",
              buttons = c("copy", "csv", "excel", "pdf", "print")
            )
          ) %>% DT::formatStyle(0, target = "row", lineHeight = "50%")
        })

        output$sgrna2.counts <- renderPlotly({
          req(robjects$set2.sgrnas, input$sgrna.gene)

          df <- robjects$set2.sgrnas
          df <- df[df$Gene == input$sgrna.gene, ]

          .make_sgrna_pairplot(df)
        })

        output$sgrna2.rank <- renderPlotly({
          req(robjects$set2.sgrnas)
          input$rank.update

          df <- robjects$set2.sgrnas

          hov.info <- c("Gene")

          highlight <- NULL
          highlight <- df$sgrna[df$Gene == input$sgrna.gene]

          .make_rank(
            df = df,
            ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
            y.thresh = 0,
            y.lines = FALSE,
            sig.thresh = 0,
            h.id = h.id,
            h.id.suffix = "_sgrank1",
            sig.term = "FDR",
            y.term = "LFC",
            x.term = "Rank",
            feat.term = "sgrna",
            hover.info = hov.info,
            fs = NULL,
            up.color = "#A6A6A6",
            down.color = "#A6A6A6",
            insig.color = "#A6A6A6",
            sig.opacity = 1,
            insig.opacity = 1,
            sig.size = 5,
            insig.size = 5,
            label.size = 8,
            webgl = TRUE,
            webgl.ratio = 7,
            show.counts = FALSE,
            show.hl.counts = FALSE,
            counts.size = 8,
            highlight.featsets = NULL,
            highlight.feats = highlight,
            featsets = NULL,
            highlight.feats.color = "red",
            highlight.feats.size = 8,
            highlight.feats.opac = 1,
            highlight.feats.linecolor = "black",
            highlight.feats.linewidth = 0.5,
            highlight.featsets.color = "#A6A6A6",
            highlight.featsets.size = 7,
            highlight.featsets.opac = 1,
            highlight.featsets.linecolor = "black",
            highlight.featsets.linewidth = 0.5
          )
        })

        output$sgrna2.detail <- renderDT({
          req(robjects$set2.sgrnas, input$sgrna.gene)

          df <- robjects$set2.sgrnas
          df <- df[df$Gene == input$sgrna.gene, ]

          target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1

          DT::datatable(df,
            rownames = FALSE,
            filter = "top",
            extensions = c("Buttons"),
            caption = paste0(input$sgrna.sel2, " ", input$sgrna.gene, " sgRNA Details"),
            options = list(
              pageLength = 10,
              dom = "Blfrtip",
              buttons = c("copy", "csv", "excel", "pdf", "print"),
              columnDefs = list(list(visible = FALSE, targets = target))
            )
          ) %>% DT::formatStyle(0, target = "row", lineHeight = "50%")
        })
      }
    })

    #--------------Comparisons Tab------------
    observe({
      .create_comparisons_observers(input, session, output, robjects)
    })

    #--------------DepMap Tab-----------------
    if (!is.null(depmap.gene)) {
      output$depmap.deplines <- renderUI({
        req(input$depmap.gene, depmap.gene)
        input$dm.dep.update

        dep.info <- get_depmap_essentiality(input$depmap.gene, depmap.gene)
        dep.release <- depmap::depmap_release()
        .make_dependency_tag(
          dep.info = dep.info,
          dep.release = dep.release,
          crispr.color = isolate(input$dep.crispr.color),
          rnai.color = isolate(input$dep.rnai.color)
        )
      })

      # Dependency
      output$depmap.essplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.dep.update

        dep.info <- plot_depmap_dependency(
          gene = input$depmap.gene,
          crispr.color = isolate(input$dep.crispr.color),
          rnai.color = isolate(input$dep.rnai.color),
          depline = isolate(input$dep.depline),
          plot.grid = isolate(input$dep.plot.grid),
          depmap.meta = depmap.meta,
          depmap.pool = pool
        )
      })

      # Expression
      output$depmap.expplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.exp.update

        dep.info <- plot_depmap_expression(
          gene = input$depmap.gene,
          depmap.meta = depmap.meta,
          depmap.pool = pool,
          color = isolate(input$exp.color),
          plot.grid = isolate(input$exp.plot.grid)
        )
      })

      # Copy number
      output$depmap.cnplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.cn.update

        dep.info <- plot_depmap_cn(
          gene = input$depmap.gene,
          depmap.meta = depmap.meta,
          depmap.pool = pool,
          color = isolate(input$cn.color),
          plot.grid = isolate(input$cn.plot.grid)
        )
      })

      # Lineage plot
      output$depmap.lineages <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.lineage.update

        dep.info <- plot_depmap_lineages(
          gene = input$depmap.gene,
          data.type = isolate(input$lin.data),
          group.by = isolate(input$lin.group),
          label.size = isolate(input$lin.label.size),
          pt.color = isolate(input$lin.pt.color),
          pt.size = isolate(input$lin.pt.size),
          boxplot.fill = isolate(input$lin.box.fill),
          boxplot.line.color = isolate(input$lin.box.color),
          depline = isolate(input$lin.depline),
          depmap.meta = depmap.meta,
          depmap.pool = pool
        )
      })

      # Sublineage plot
      output$depmap.sublineage <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.sublineage.update

        dep.info <- plot_depmap_lineages(
          gene = input$depmap.gene,
          data.type = isolate(input$lin.data),
          group.by = "lineage_subtype",
          lineage = isolate(input$sub.lineage),
          label.size = isolate(input$sub.label.size),
          pt.color = isolate(input$sub.pt.color),
          pt.size = isolate(input$sub.pt.size),
          boxplot.fill = isolate(input$sub.box.fill),
          boxplot.line.color = isolate(input$sub.box.color),
          depline = isolate(input$sub.depline),
          depmap.meta = depmap.meta,
          depmap.pool = pool
        )
      })

      # Gene info
      output$depmap.geneinfo <- renderUI({
        req(input$depmap.gene, depmap.gene)

        .make_gene_tag(input$depmap.gene)
      })
    }
  }

  if (return.app) {
    shinyApp(ui, server)
  } else {
    return(list(ui = ui, server = server))
  }
}
