#' Create an interactive Shiny app for visualization & exploration of MAGeCK RRA CRISPR analyses
#'
#' This shiny app is composed of multiple tabs to peruse RRA results and compare them between timepoints or samples.
#' Also included are numerous QC plots. Almost all plots are interactive and their aesthetics can be easily tweaked
#' using the sidebar. See the Details section for more information.
#'
#' Gene labels can be added to the MAplot and volcano plot by clicking a point. The labels can also be dragged around,
#' though adding labels will reset the positions, so it's recommended to add all labels prior to re-positioning them.
#'
#' @details Features with no variation will be removed prior to \code{\link[PCAtools]{pca}} being run for the PCA visualization.
#'
#' @rawNamespace import(shiny, except = c(dataTableOutput, renderDataTable))
#' @importFrom ComplexHeatmap Heatmap pheatmap
#' @import DT
#' @importFrom plotly ggplotly plotlyOutput renderPlotly toWebGL plot_ly layout add_annotations add_segments config toRGB event_data add_trace
#' @import ggplot2
#' @importFrom shinyWidgets prettyCheckbox dropdownButton tooltipOptions pickerInput updatePickerInput
#' @importFrom shinycssloaders withSpinner
#' @importFrom shinyjqui jqui_resizable
#' @importFrom shinyjs show useShinyjs hidden disable click extendShinyjs js
#' @importFrom shinyBS tipify popify
#' @importFrom colourpicker colourInput
#' @importFrom MAGeCKFlute BarView MapRatesView
#' @importFrom PCAtools pca
#' @importFrom dittoSeq dittoColors
#' @importFrom grid grid.newpage grid.text
#' @importFrom matrixStats rowVars rowMaxs rowMins
#' @importFrom graphics hist legend lines
#' @importFrom stats cor
#' @importFrom utils read.csv
#'
#' @param gene.data A named list containing \code{gene_summary.txt} tables as data.frames.
#'   Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{grna.data} list elements.
#' @param sgrna.data A named list containing \code{sgrna_summary.txt} tables as data.frames.
#'   Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{gene.data} list elements.
#' @param count.summary Matrix or dataframe containing count summary (\code{countsummary.txt}) as generated by \code{mageck count}.
#' @param norm.counts Matrix or dataframe containing normalized counts (\code{count_normalized.txt}) as generated by \code{mageck count}.
#' @param h.id String indicating unique ID for interactive plots.
#'   Required if multiple apps are run within the same Rmd file.
#' @param positive.ctrl.genes Optional character vector of gene identifiers for
#'   positive control genes from the screen so that they can be easily filtered.
#' @param essential.genes Optional character vector of gene identifiers of common
#'   essential genes (i.e. pan-lethal) so that they can be easily filtered.
#'   If provided, overrides the depmap essential genes.
#' @param depmap.db Optional character scalar for name of SQLite database returned by \code{\link{build_depmap_db}}.
#' @param genesets Optional named list containing genesets that can be interactively highlighted on the plots.
#'   The elements of the list should each be a geneset with gene identifiers matching those used in the results.
#' @param return.app Optional boolean indicating whether a Shiny app should be returned. \code{TRUE} by default. If \code{FALSE},
#'   a named list of app elements (ui and server) will be returned instead. Useful for deploying as a standalone shiny app.
#'
#' @return A Shiny app containing interactive visualizations of MAGeCK RRA analysis results.
#'
#'
#' @author Jared Andrews
#' @export
CRISPRball <- function(gene.data = NULL, sgrna.data = NULL, count.summary = NULL, norm.counts = NULL, h.id = "mag1",
                       positive.ctrl.genes = NULL, essential.genes = NULL,
                       depmap.db = NULL, genesets = NULL, return.app = TRUE) {

  # Increase file upload size limit to 50MB, which should cover pretty much any use case.
  options(shiny.maxRequestSize = 50*1024^2)
  
  # Set initial metadata and dataset choices if input data isn't NULL.
  gene.choices <- NULL
  sgrna.choices <- NULL
  summ.choices <- NULL
  sgrna.gene <- NULL

  default.tab <- NULL
  
  if (!is.null(gene.data)) {
    gene.choices <- names(gene.data)
  }
  
  if (!is.null(sgrna.data)) {
    sgrna.choices <- names(sgrna.data)
    sgrna.gene <- unique(c(sgrna.data[[1]]$Gene))
  }
  
  if (!is.null(count.summary)) {
    summ.choices <- colnames(count.summary)
    default.tab <- "QC"
  }
  
  # Load cell line metadata and gene summaries if depmap db provided.
  if (!is.null(depmap.db)) {
    .error_if_no_pool()
    .error_if_no_rsqlite()

    pool <- pool::dbPool(RSQLite::SQLite(), dbname = depmap.db)
    depmap.meta <- pool::dbGetQuery(pool, "SELECT * FROM 'meta'")
    depmap.gene <- pool::dbGetQuery(pool, "SELECT * FROM 'gene.summary'")

    # Close db on app close.
    onStop(function() {pool::poolClose(pool)})
  } else {
    depmap.meta <- NULL
    depmap.gene <- NULL
  }

  ui <- navbarPage(
    "CRISPRball",
    selected = default.tab,
    useShinyjs(),
    extendShinyjs(text=.utils.js, functions = c('disableTab','enableTab')),
    tags$head(
      # Note the wrapping of the string in HTML()
      tags$style(HTML("
          .panel-body {
            padding: 5px;
          }
          .form-group {
            margin-bottom: 3px;
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            line-height: 1.1;
          }
          .well {
            padding: 5px;
            margin-bottom: 10px;
          }
          .form-control, .selectize-input {
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            height: 24px;
            min-height: 24px;
            line-height: 1.1;
          }
          .control-label {
            font-size: 10px;
            margin-bottom: 2px;
          }
          .panel-heading {
            padding: 5px 10px;
          }
          .selectize-control {
            margin-bottom: 0px;
          }
          .btn-file {
            padding: 1px 12px;
          }
          body {
            line-height: 1.1;
          }
          hr{
            margin-top: 3px;
            margin-bottom: 3px;
          }
          .panel-group {
            margin-bottom: 8px;
          }
          h3 {
            margin-top: 0px;
          }
          .nav li a.disabled {
            background-color: #aaa !important;
            color: #333 !important;
            cursor: not-allowed !important;
            border-color: #aaa !important;
          }
        "))
    ),
    # ---------------Data Upload-----------------
    tab_data_upload,
    # ----------------QC--------------------
    .tab_qc(summ.choices),
    # -------------------QC Table----------------
    tabPanel(
      title = "QC Table",
      id = "qc-table",
      br(),
      DTOutput("count.summary")
    ),
    # ------------------Gene (Overview)-------------
    .tab_gene(gene.choices, genesets),
    # ----------------Gene Summary Tables--------------
    tabPanel(
      title = "Gene Summary Tables",
      id = "gene-summ",
      br(),
      div(DT::dataTableOutput("gene1.summary"), style = "font-size:80%;"),
      br(),
      div(DT::dataTableOutput("gene2.summary"), style = "font-size:80%;")
    ),
    # ----------------sgRNA---------------------
    .tab_sgrna(sgrna.choices, sgrna.gene),
    # --------------------sgRNA Summary Tables----------------
    tabPanel(
      title = "sgRNA Summary Tables",
      id = "sgrna-tables",
      br(),
      div(DT::dataTableOutput("sgrna1.summary"), style = "font-size:80%;"),
      br(),
      div(DT::dataTableOutput("sgrna2.summary"), style = "font-size:80%;")
    ),
    # -----------------DepMap-------------------
    .tab_depmap(sgrna.data, depmap.meta),
    # -----------------About-------------------
    tab_about
  )

  server <- function(input, output, session) {

    # --------------Disable Tabs-----------------
    defaultDisabledTabs <- c()

    if (is.null(gene.data)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "Gene (Overview)", "Gene Summary Tables")
    }

    if (is.null(sgrna.data)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "sgRNA", "sgRNA Summary Tables")
    }

    if (is.null(count.summary) | is.null(norm.counts)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "QC", "QC Table")
    }

    for (tabname in defaultDisabledTabs) {
      js$disableTab(tabname)
    }

    # -------------Reactive Values---------------

    gene.data <- reactiveVal(gene.data)
    sgrna.data <- reactiveVal(sgrna.data)
    count.summary <- reactiveVal(count.summary)
    norm.counts <- reactiveVal(norm.counts)


    # -----------Loading Files In----------------
    # Update inputs and data reactives as necessary.
    observeEvent(input$geneSummaryFiles, {
      new.data <- .gene_summ_ingress(input$geneSummaryFiles)
      gene.data(new.data)
      if (!is.null(gene.data())) {
        js$enableTab('Gene (Overview)')
        js$enableTab('Gene Summary Tables')
        updateSelectizeInput(session, 'gene.sel1', choices = names(gene.data()), server = TRUE)
        updateSelectizeInput(session, 'gene.sel2', choices = names(gene.data()), server = TRUE)
      }
    })

    observeEvent(input$sgrnaSummaryFiles, {
      new.data <- .sgrna_summ_ingress(input$sgrnaSummaryFiles)
      sgrna.data(new.data)
      if (!is.null(sgrna.data())) {
        js$enableTab('sgRNA')
        js$enableTab('sgRNA Summary Tables')
        updateSelectizeInput(session, 'sgrna.sel1', choices = names(sgrna.data()), server = TRUE)
        updateSelectizeInput(session, 'sgrna.sel2', choices = names(sgrna.data()), server = TRUE)
        updatePickerInput(session, 'sgrna.gene', choices = unique(c(sgrna.data()[[1]]$Gene)))
      }
    })

    observeEvent(input$countSummary, {
      new.data <- read.delim(input$countSummary$datapath)
      count.summary(new.data)
      if (!is.null(count.summary())) {
        js$enableTab('QC')
        js$enableTab('QC Table')
        updateSelectizeInput(session, 'bip.color', choices = c('', colnames(count.summary())), server = TRUE)
        updateSelectizeInput(session, 'bip.shape', choices = c('', colnames(count.summary())), server = TRUE)
      }
    })

    observeEvent(input$countNormFile, {
      new.data <- read.delim(input$countNormFile$datapath)
      norm.counts(new.data)
      if (!is.null(norm.counts())) {
        js$enableTab('QC')
      }
    })

    # Hide depmap tab if database not provided. 
    # Tried disable, still looks/feels selectable which may be confusing.
    if (is.null(depmap.db)) {
      shinyjs::hide(selector = '.navbar-nav a[data-value="DepMap"')
    }


    # -----------QC & QC Summary Tabs------------
    # PCA.

    pc <- reactive({
      req(norm.counts)
      req(count.summary)

      slmed <- norm.counts()
      slmat <- as.matrix(slmed[,c(-1,-2)])
      mat <- log2(slmat+1)
      rownames(mat) <- slmed$sgRNA
  
      req(input$var.remove)
      meta <- count.summary()

      # Filter samples from QC table.
      if (!is.null(input$count.summary_rows_all) & input$meta.filt) {
        meta <- count.summary()[input$count.summary_rows_all,]
        mat <- mat[,input$count.summary_rows_all]
      }

      rownames(meta) <- gsub("-", ".", meta$Label)
      
      # Remove guides with no variance in counts, as they break the PCA.
      mat <- mat[(rowMaxs(mat) - rowMins(mat) > 0),]

      # If input to use top N features instead rather than percent-based feature removal, account for that
      if (input$keep.top.n) {
        mat <- mat[order(rowVars(mat), decreasing = TRUE),]
        mat <- mat[1:input$var.n.keep,]
        var.remove <- 0
      } else {
        var.remove <- input$var.remove
      }
      
      meta <- meta[colnames(mat),]

      if (ncol(mat) > 1) {

        pca(mat,
            metadata = meta,
            removeVar = var.remove,
            scale = input$scale,
            center = input$center)

      } else {
        NULL
      }
    })

    # Populate UI with all PCs.
    # TODO: Write check for only 2 PCs.
    output$pca.comps <- renderUI({
      req(pc)
      pcs <- pc()

      tagList(
        fluidRow(
          column(4, selectInput("dim1", "Dim1:", choices = pcs$components, selected = "PC1")),
          column(4, selectInput("dim2", "Dim2:", choices = pcs$components, selected = "PC2")),
          column(4, selectInput("dim3", "Dim3:", choices = pcs$components, selected = "PC3"))
        )
      )
    })

    output$qc.gini <- renderPlotly({
      gg <- BarView(count.summary(),
                    x = "Label",
                    y = "GiniIndex",
                    ylab = "Gini index",
                    main = "sgRNA Read Distribution")

      gg + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                 axis.text.y = element_text(size = 12))

      ggplotly(gg, tooltip = c("y")) %>%
        layout(yaxis = list(range = list(0, max(count.summary()$GiniIndex) + .05)),
               xaxis = list(tickangle = 315)) %>%
        config(toImageButtonOptions = list(format = "svg"),
               displaylogo = FALSE,
               plotGlPixelRatio = 7)
    })

    output$qc.missed <- renderPlotly({
      gg <- BarView(count.summary(), x = "Label", y = "Zerocounts", fill = "#394E80",
                    ylab = "Zero Count sgRNAs", main = "Fully Depleted sgRNAs")

      gg + theme_classic() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                                   axis.text.y = element_text(size = 12)) + ylim(0, max(count.summary()$Zerocounts) + 5)

      ggplotly(gg, tooltip = c("y")) %>%
        layout(yaxis = list(range = list(0, max(count.summary()$Zerocounts) + 5)),
               xaxis = list(tickangle = 315)) %>%
        config(toImageButtonOptions = list(format = "svg"),
               displaylogo = FALSE,
               plotGlPixelRatio = 7)
    })

    output$qc.map <- renderPlot({
      MapRatesView(count.summary())
    })

    # TODO: rewrite this.
    observeEvent(norm.counts, {
      output$qc.histplot <- renderPlot({
        colors <- dittoColors()

        slmed <- norm.counts()
        tabsmat <- as.matrix(log2(slmed[,c(-1,-2)] + 1))
        colnames(tabsmat) <- colnames(slmed)[c(-1,-2)]
        samplecol <- colors[((1:ncol(tabsmat)) %% length(colors))]
        tgz <- hist(tabsmat, breaks = 40)

        if(ncol(tabsmat) >= 1) {
          histlist <- lapply(1:ncol(tabsmat), function(X) { return (hist(tabsmat[,X], plot=FALSE, breaks=tgz$breaks)) })
          xrange <- range(unlist(lapply(histlist, function(X) {X$mids})))
          yrange <- range(unlist(lapply(histlist, function(X) {X$counts})))
          hst1 <- histlist[[1]]
          plot(hst1$mids, hst1$counts, type='b', pch=20, xlim=c(0,xrange[2]*1.2),
               ylim=c(0,yrange[2]*1.2), xlab='log2(counts)', ylab='Frequency',
               main='Distribution of read counts', col = samplecol[1])
        }

        if(ncol(tabsmat) >= 2){
          for(i in 2:ncol(tabsmat)){
            hstn <- histlist[[i]]
            lines(hstn$mids, hstn$counts, type='b', pch=20, col=samplecol[i])
          }
        }

        legend('topright', colnames(tabsmat), pch=20, lwd=1, col=samplecol)
      })

      # TODO: rewrite this, add color min/max/mid selectors.
      output$qc.corr <- renderPlot({
        slmed <- norm.counts()
        slmat <- as.matrix(slmed[,c(-1,-2)])
        slmat.log <- log2(slmat+1)

        if (ncol(slmat.log) > 1){
          ComplexHeatmap::pheatmap(cor(slmat.log),
                                   heatmap_legend_param = list(title = "Pearson\nCorr."),
                                   main = "Correlation Matrix")
        } else {
          grid.newpage()
          grid.text("Only one sample, no correlation possible.")
        }

      })
    })

    observeEvent(pc, {
      output$qc.pca <- renderPlotly({
        req(pc, input$dim1, input$dim2, input$dim3)
        input$pca.update

        pc.res <- isolate(pc())

        pl.cols <- NULL
        pl.shapes <- NULL
        pl.col <- "black"
        hov.text <- NULL

        # Get marker aesthetics mappings.
        # Drop unused factor levels if possible.
        if (isolate(input$bip.color) != "") {
          pl.cols <- pc.res$metadata[,isolate(input$bip.color), drop = TRUE]
          if (is.factor(pl.cols)) {
            pl.cols <- droplevels(pl.cols)
          }
          pl.col <- dittoColors()[seq_along(unique(pc.res$metadata[,isolate(input$bip.color), drop = TRUE]))]
        }

        if (isolate(input$bip.shape) != "") {
          pl.shapes <- pc.res$metadata[,isolate(input$bip.shape), drop = TRUE]
          if (is.factor(pl.shapes)) {
            pl.shapes <- droplevels(pl.shapes)
          }
        }

        # Just throw label on hover for now.
        hov.text <- paste0("</br><b>Label:</b> ", pc.res$metadata$Label)

        # Check if 2D is wanted.
        if (isolate(input$bip.twod)) {
          fig <- plot_ly(pc.res$rotated,
                         x = as.formula(paste0("~", isolate(input$dim1))),
                         y = as.formula(paste0("~", isolate(input$dim2))),
                         type = "scatter",
                         mode = "markers",
                         marker = list(size = 15),
                         color = pl.cols,
                         colors = pl.col,
                         symbol = pl.shapes,
                         symbols = c("circle", "square", "diamond", "cross",
                                     "diamond-open", "circle-open", "square-open", "x"),
                         text = hov.text,
                         hoverinfo = "text") %>%
            layout(xaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                                title = paste0(isolate(input$dim1),
                                               " (", format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
                   yaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                                title = paste0(isolate(input$dim2),
                                               " (", format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")))

          fig <- fig %>% toWebGL()

          # Plot loadings.
          if (isolate(input$bip.loadings)) {
            lengthLoadingsArrowsFactor <- 1.5

            # Get number of loadings to display.
            xidx <- order(abs(pc.res$loadings[,isolate(input$dim1)]), decreasing = TRUE)
            yidx <- order(abs(pc.res$loadings[,isolate(input$dim2)]), decreasing = TRUE)
            vars <- unique(c(
              rownames(pc.res$loadings)[xidx][seq_len(isolate(input$bip.n.loadings))],
              rownames(pc.res$loadings)[yidx][seq_len(isolate(input$bip.n.loadings))]))

            # get scaling parameter to match between variable loadings and rotated loadings
            # This is cribbed almost verbatim from PCAtools code.
            r <- min(
              (max(pc.res$rotated[,isolate(input$dim1)]) - min(pc.res$rotated[,isolate(input$dim1)]) /
                 (max(pc.res$loadings[,isolate(input$dim1)]) - min(pc.res$loadings[,isolate(input$dim1)]))),
              (max(pc.res$rotated[,isolate(input$dim2)]) - min(pc.res$rotated[,isolate(input$dim2)]) /
                 (max(pc.res$loadings[,isolate(input$dim2)]) - min(pc.res$loadings[,isolate(input$dim2)]))))

            fig <- fig %>%
              add_segments(x = 0, xend = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                           y = 0, yend = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                           line = list(color = 'black'), inherit = FALSE, showlegend = FALSE, hoverinfo = "text") %>%
              add_annotations(x = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                              y = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                              ax = 0, ay = 0, text = vars, xanchor = 'center', yanchor= 'bottom')
          }
        } else {

          # Generate plot.
          fig <- plot_ly(pc.res$rotated, x = as.formula(paste0("~", isolate(input$dim1))),
                         y = as.formula(paste0("~", isolate(input$dim2))),
                         z = as.formula(paste0("~", isolate(input$dim3))),
                         type = "scatter3d",
                         mode = "markers",
                         color = pl.cols,
                         colors = pl.col,
                         symbol = pl.shapes,
                         symbols = c("circle", "square", "diamond", "cross", "diamond-open",
                                     "circle-open", "square-open", "x"),
                         text = hov.text,
                         hoverinfo = "text") %>%
            layout(scene = list(
              xaxis = list(title = paste0(isolate(input$dim1), " (",
                                          format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
              yaxis = list(title = paste0(isolate(input$dim2), " (",
                                          format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")),
              zaxis = list(title = paste0(isolate(input$dim3), " (",
                                          format(round(pc.res$variance[isolate(input$dim3)], 2), nsmall = 2),"%)")),
              camera = list(eye = list(x=1.5, y = 1.8, z = 0.4))))
        }
        fig <- fig %>%
          config(edits = list(annotationPosition = TRUE,
                              annotationTail = FALSE),
                 toImageButtonOptions = list(format = "svg"),
                 displaylogo = FALSE,
                 plotGlPixelRatio = 7)

        fig
      })
    })

    observeEvent(count.summary, {
      output$count.summary <- renderDT(server = FALSE, {
        DT::datatable(count.summary(),
                      rownames = FALSE,
                      filter = "top",
                      extensions = c("Buttons", "Scroller"),
                      options = list(
                        search = list(regex = TRUE),
                        lengthMenu = list(c(10, 25, 50, -1), c("10", "25", "50", "all")),
                        dom = 'Blfrtip',
                        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                        scrollX = TRUE,
                        deferRender = TRUE,
                        scrollY = 600,
                        scroller = TRUE)
        ) %>% DT::formatStyle(0, target = "row", lineHeight = '80%')
      })
    })

    # Initialize plots by simulating button click once.
    o <- observe({
      req(pc, input$dim1, input$dim2, input$dim3)
      shinyjs::click("pca.update")
      o$destroy
    })

    #---------Gene (Overview) & Summary Tables Tabs-------------
    # Remove certain outputs if parameters for them are not provided.
    if (is.null(depmap.gene)) {
      shinyjs::hide("dep.crispr.ess")
      shinyjs::hide("dep.crispr.sel")
      shinyjs::hide("dep.rnai.ess")
      shinyjs::hide("dep.rnai.sel")
    }


    if (is.null(essential.genes)) {
      shinyjs::hide("rem.ess")
    }


    if (is.null(positive.ctrl.genes)) {
      shinyjs::hide("rem.pos")
    }


    # Disable certain inputs if only one dataset provided.
    observe({
      if (length(gene.data()) == 1) {
        shinyjs::disable("gene.sel2")
        shinyjs::hide("highlight.common")
      }
    })


    # Load the gene summaries for easy plotting.
    set1.genes <- reactive({
      df <- gene.data()[[input$gene.sel1]]
      .gene_ingress(df, sig.thresh = isolate(input$gene.fdr.th), lfc.thresh = isolate(input$gene.lfc.th),
                    positive.ctrl.genes = positive.ctrl.genes, essential.genes = essential.genes, depmap.genes = depmap.gene)
    })

    set2.genes <- reactive({
      if (length(gene.data()) > 1) {
        df <- gene.data()[[input$gene.sel2]]
        .gene_ingress(df, sig.thresh = isolate(input$gene.fdr.th), lfc.thresh = isolate(input$gene.lfc.th),
                      positive.ctrl.genes = positive.ctrl.genes, essential.genes = essential.genes, depmap.genes = depmap.gene)
      }
    })


    # Get overlapping hits between sets if needed.
    common.hits <- reactive({
      req(set1.genes, set2.genes)
      s1 <- set1.genes()
      s2 <- set2.genes()

      set1.hits <- s1$id[s1$hit_type %in% c("neg", "pos")]
      set2.hits <- s2$id[s2$hit_type %in% c("neg", "pos")]

      set1.hits[set1.hits %in% set2.hits]
    })

    # Keep track of which genes have been clicked
    clicked <- reactiveValues(volc1 = NULL, rank1 = NULL, lawn1 = NULL, volc2 = NULL, rank2 = NULL, lawn2 = NULL)

    # On click, the key field of the event data contains the gene symbol.
    # Add that gene to the set of all "selected" genes. Double click will clear all labels.
    # TODO: lapply this, probably.
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_volc1"))
      gene_old_new <- rbind(clicked$volc1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$volc1 <- NULL
      } else {
        clicked$volc1 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_rank1"))
      gene_old_new <- rbind(clicked$rank1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$rank1 <- NULL
      } else {
        clicked$rank1 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_lawn1"))
      gene_old_new <- rbind(clicked$lawn1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$lawn1 <- NULL
      } else {
        clicked$lawn1 <- keep
      }
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc1")), {
      clicked$volc1 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank1")), {
      clicked$rank1 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn1")), {
      clicked$lawn1 <- NULL
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_volc2"))
      gene_old_new <- rbind(clicked$volc2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$volc2 <- NULL
      } else {
        clicked$volc2 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_rank2"))
      gene_old_new <- rbind(clicked$rank2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$rank2 <- NULL
      } else {
        clicked$rank2 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_lawn2"))
      gene_old_new <- rbind(clicked$lawn2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$lawn2 <- NULL
      } else {
        clicked$lawn2 <- keep
      }
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc2")), {
      clicked$volc2 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank2")), {
      clicked$rank2 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn2")), {
      clicked$lawn2 <- NULL
    })

    # Summary table and plots.
    output$gene1.summary <- renderDT(server = FALSE, {
      req(set1.genes)
      # Remove columns that are redundant or confusing.
      target <- which(names(set1.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",
                                                 "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
                                                 "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1

      df <- set1.genes()

      if (!is.null(common.hits)) {
        df$Overlap <- df$id %in% common.hits()
      }

      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$gene.sel1, " Gene Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    output$gene1.vol <- renderPlotly({
      req(set1.genes)
      input$vol.update

      df <- set1.genes()

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }


      .make_volcano(res = df,
                    xlim = isolate(input$vol.x),
                    ylim = isolate(input$vol.y),
                    fc.thresh = isolate(input$gene.lfc.th),
                    fc.lines = isolate(input$vol.fcline),
                    sig.thresh = isolate(input$gene.fdr.th),
                    sig.line = isolate(input$vol.sigline),
                    h.id = h.id,
                    h.id.suffix = "_volc1",
                    sig.term = "FDR",
                    lfc.term = "LFC",
                    feat.term = "id",
                    hover.info = hov.info,
                    fs = clicked$volc1,
                    up.color = isolate(input$up.color),
                    down.color = isolate(input$down.color),
                    insig.color = isolate(input$insig.color),
                    sig.opacity = isolate(input$sig.opa),
                    insig.opacity = isolate(input$insig.opa),
                    sig.size = isolate(input$sig.size),
                    insig.size = isolate(input$insig.size),
                    label.size = isolate(input$lab.size),
                    webgl = isolate(input$webgl),
                    webgl.ratio = isolate(input$webgl.ratio),
                    show.counts = isolate(input$counts),
                    show.hl.counts = isolate(input$hl.counts),
                    counts.size = isolate(input$counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feats = highlight,
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })

    output$gene1.rank <- renderPlotly({
      req(set1.genes)
      input$rank.update

      df <- set1.genes()

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }

      .make_rank(df = df,
                 ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                 y.thresh = isolate(input$gene.lfc.th),
                 y.lines = isolate(input$rank.fcline),
                 sig.thresh = isolate(input$gene.fdr.th),
                 h.id = h.id,
                 h.id.suffix = "_rank1",
                 sig.term = "FDR",
                 y.term = "LFC",
                 x.term = "Rank",
                 feat.term = "id",
                 hover.info = c("hit_type", "goodsgrna"),
                 fs = clicked$rank1,
                 up.color = isolate(input$up.color),
                 down.color = isolate(input$down.color),
                 insig.color = isolate(input$insig.color),
                 sig.opacity = isolate(input$sig.opa),
                 insig.opacity = isolate(input$insig.opa),
                 sig.size = isolate(input$sig.size),
                 insig.size = isolate(input$insig.size),
                 label.size = isolate(input$lab.size),
                 webgl = isolate(input$webgl),
                 webgl.ratio = isolate(input$webgl.ratio),
                 show.counts = isolate(input$counts),
                 show.hl.counts = isolate(input$hl.counts),
                 counts.size = isolate(input$counts.size),
                 highlight.featsets = isolate(input$hl.genesets),
                 highlight.feats = highlight,
                 featsets = genesets,
                 highlight.feats.color = isolate(input$hl.genes.col),
                 highlight.feats.size = isolate(input$hl.genes.size),
                 highlight.feats.opac = isolate(input$hl.genes.opa),
                 highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                 highlight.feats.linewidth = isolate(input$hl.genes.lw),
                 highlight.featsets.color = isolate(input$hl.genesets.col),
                 highlight.featsets.size = isolate(input$hl.genesets.size),
                 highlight.featsets.opac = isolate(input$hl.genesets.opa),
                 highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                 highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })

    output$gene1.lawn <- renderPlotly({
      req(set1.genes)
      df <- set1.genes()
      input$lawn.update

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }

      .make_lawn(res = df,
                 ylim = isolate(input$lawn.y),
                 fc.thresh = isolate(input$gene.lfc.th),
                 sig.thresh = isolate(input$gene.fdr.th),
                 sig.line = isolate(input$lawn.sigline),
                 h.id = h.id,
                 h.id.suffix = "_lawn1",
                 sig.term = "FDR",
                 lfc.term = "LFC",
                 feat.term = "id",
                 x.term = "RandomIndex",
                 hover.info = hov.info,
                 fs = clicked$lawn1,
                 up.color = isolate(input$up.color),
                 down.color = isolate(input$down.color),
                 insig.color = isolate(input$insig.color),
                 sig.opacity = isolate(input$sig.opa),
                 insig.opacity = isolate(input$insig.opa),
                 sig.size = isolate(input$sig.size),
                 insig.size = isolate(input$insig.size),
                 label.size = isolate(input$lab.size),
                 webgl = isolate(input$webgl),
                 webgl.ratio = isolate(input$webgl.ratio),
                 show.counts = isolate(input$counts),
                 show.hl.counts = isolate(input$hl.counts),
                 counts.size = isolate(input$counts.size),
                 highlight.featsets = isolate(input$hl.genesets),
                 highlight.feats = highlight,
                 featsets = genesets,
                 highlight.feats.color = isolate(input$hl.genes.col),
                 highlight.feats.size = isolate(input$hl.genes.size),
                 highlight.feats.opac = isolate(input$hl.genes.opa),
                 highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                 highlight.feats.linewidth = isolate(input$hl.genes.lw),
                 highlight.featsets.color = isolate(input$hl.genesets.col),
                 highlight.featsets.size = isolate(input$hl.genesets.size),
                 highlight.featsets.opac = isolate(input$hl.genesets.opa),
                 highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                 highlight.featsets.linewidth = isolate(input$hl.genesets.lw))

    })

    # If only one dataset provided, don't render second dataset.
    observe({if (length(gene.data()) > 1) {
      output$gene2.summary <- renderDT(server = FALSE, {
        req(set2.genes)
        # Remove columns that are redundant or confusing.
        target <- which(names(set2.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",
                                                   "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
                                                   "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1

        df <- set2.genes()

        # Label overlapping hits between datasets if available.
        if (!is.null(common.hits())) {
          df$Overlap <- df$id %in% common.hits()
        }

        DT::datatable(df,
                      rownames = FALSE,
                      filter = "top",
                      extensions = c("Buttons"),
                      caption = paste0(input$gene.sel2, " Gene Summary"),
                      options = list(
                        search = list(regex = TRUE),
                        dom = 'Blfrtip',
                        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                        pageLength = 10,
                        columnDefs = list(list(visible = FALSE, targets = target)))
        ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
      })

      output$gene2.vol <- renderPlotly({
        req(set2.genes)
        input$vol.update

        df <- set2.genes()

        hov.info <- c("hit_type", "num", "goodsgrna")

        # Remove common essential genes if needed.
        if (isolate(input$rem.ess) & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove positive control genes if needed.
        if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
          df <- df[!df$Positive_Control,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (isolate(input$dep.crispr.ess)) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (isolate(input$dep.crispr.sel)) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (isolate(input$dep.rnai.ess)) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (isolate(input$dep.rnai.sel)) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }


        .make_volcano(res = df,
                      xlim = isolate(input$vol.x),
                      ylim = isolate(input$vol.y),
                      fc.thresh = isolate(input$gene.lfc.th),
                      fc.lines = isolate(input$vol.fcline),
                      sig.thresh = isolate(input$gene.fdr.th),
                      sig.line = isolate(input$vol.sigline),
                      h.id = h.id,
                      h.id.suffix = "_volc2",
                      sig.term = "FDR",
                      lfc.term = "LFC",
                      feat.term = "id",
                      hover.info = hov.info,
                      fs = clicked$volc2,
                      up.color = isolate(input$up.color),
                      down.color = isolate(input$down.color),
                      insig.color = isolate(input$insig.color),
                      sig.opacity = isolate(input$sig.opa),
                      insig.opacity = isolate(input$insig.opa),
                      sig.size = isolate(input$sig.size),
                      insig.size = isolate(input$insig.size),
                      label.size = isolate(input$lab.size),
                      webgl = isolate(input$webgl),
                      webgl.ratio = isolate(input$webgl.ratio),
                      show.counts = isolate(input$counts),
                      show.hl.counts = isolate(input$hl.counts),
                      counts.size = isolate(input$counts.size),
                      highlight.featsets = isolate(input$hl.genesets),
                      highlight.feats = highlight,
                      featsets = genesets,
                      highlight.feats.color = isolate(input$hl.genes.col),
                      highlight.feats.size = isolate(input$hl.genes.size),
                      highlight.feats.opac = isolate(input$hl.genes.opa),
                      highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                      highlight.feats.linewidth = isolate(input$hl.genes.lw),
                      highlight.featsets.color = isolate(input$hl.genesets.col),
                      highlight.featsets.size = isolate(input$hl.genesets.size),
                      highlight.featsets.opac = isolate(input$hl.genesets.opa),
                      highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                      highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      })

      output$gene2.rank <- renderPlotly({
        req(set2.genes)
        input$rank.update

        hov.info <- c("hit_type", "num", "goodsgrna")

        df <- set2.genes()

        # Remove common essential genes if needed.
        if (isolate(input$rem.ess) & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove positive control genes if needed.
        if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
          df <- df[!df$Positive_Control,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (isolate(input$dep.crispr.ess)) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (isolate(input$dep.crispr.sel)) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (isolate(input$dep.rnai.ess)) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (isolate(input$dep.rnai.sel)) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }

        .make_rank(df = df,
                   ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                   y.thresh = isolate(input$gene.lfc.th),
                   y.lines = isolate(input$rank.fcline),
                   sig.thresh = isolate(input$gene.fdr.th),
                   h.id = h.id,
                   h.id.suffix = "_rank2",
                   sig.term = "FDR",
                   y.term = "LFC",
                   x.term = "Rank",
                   feat.term = "id",
                   hover.info = hov.info,
                   fs = clicked$rank2,
                   up.color = isolate(input$up.color),
                   down.color = isolate(input$down.color),
                   insig.color = isolate(input$insig.color),
                   sig.opacity = isolate(input$sig.opa),
                   insig.opacity = isolate(input$insig.opa),
                   sig.size = isolate(input$sig.size),
                   insig.size = isolate(input$insig.size),
                   label.size = isolate(input$lab.size),
                   webgl = isolate(input$webgl),
                   webgl.ratio = isolate(input$webgl.ratio),
                   show.counts = isolate(input$counts),
                   show.hl.counts = isolate(input$hl.counts),
                   counts.size = isolate(input$counts.size),
                   highlight.featsets = isolate(input$hl.genesets),
                   highlight.feats = highlight,
                   featsets = genesets,
                   highlight.feats.color = isolate(input$hl.genes.col),
                   highlight.feats.size = isolate(input$hl.genes.size),
                   highlight.feats.opac = isolate(input$hl.genes.opa),
                   highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                   highlight.feats.linewidth = isolate(input$hl.genes.lw),
                   highlight.featsets.color = isolate(input$hl.genesets.col),
                   highlight.featsets.size = isolate(input$hl.genesets.size),
                   highlight.featsets.opac = isolate(input$hl.genesets.opa),
                   highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                   highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      })

      output$gene2.lawn <- renderPlotly({
        req(set2.genes)
        input$lawn.update

        hov.info <- c("hit_type", "num", "goodsgrna")

        df <- set2.genes()

        # Remove common essential genes if needed.
        if (isolate(input$rem.ess) & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove positive control genes if needed.
        if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
          df <- df[!df$Positive_Control,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (isolate(input$dep.crispr.ess)) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (isolate(input$dep.crispr.sel)) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (isolate(input$dep.rnai.ess)) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (isolate(input$dep.rnai.sel)) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }

        .make_lawn(res = df,
                   ylim = isolate(input$lawn.y),
                   fc.thresh = isolate(input$gene.lfc.th),
                   sig.thresh = isolate(input$gene.fdr.th),
                   sig.line = isolate(input$lawn.sigline),
                   h.id = h.id,
                   h.id.suffix = "_lawn2",
                   sig.term = "FDR",
                   lfc.term = "LFC",
                   feat.term = "id",
                   x.term = "RandomIndex",
                   hover.info = hov.info,
                   fs = clicked$lawn2,
                   up.color = isolate(input$up.color),
                   down.color = isolate(input$down.color),
                   insig.color = isolate(input$insig.color),
                   sig.opacity = isolate(input$sig.opa),
                   insig.opacity = isolate(input$insig.opa),
                   sig.size = isolate(input$sig.size),
                   insig.size = isolate(input$insig.size),
                   label.size = isolate(input$lab.size),
                   webgl = isolate(input$webgl),
                   webgl.ratio = isolate(input$webgl.ratio),
                   show.counts = isolate(input$counts),
                   show.hl.counts = isolate(input$hl.counts),
                   counts.size = isolate(input$counts.size),
                   highlight.featsets = isolate(input$hl.genesets),
                   highlight.feats = highlight,
                   featsets = genesets,
                   highlight.feats.color = isolate(input$hl.genes.col),
                   highlight.feats.size = isolate(input$hl.genes.size),
                   highlight.feats.opac = isolate(input$hl.genes.opa),
                   highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                   highlight.feats.linewidth = isolate(input$hl.genes.lw),
                   highlight.featsets.color = isolate(input$hl.genesets.col),
                   highlight.featsets.size = isolate(input$hl.genesets.size),
                   highlight.featsets.opac = isolate(input$hl.genesets.opa),
                   highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                   highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      }
      )
    }
    }
    )

    # If the Gene tab update button is pressed, click all the update buttons.
    observeEvent(input$gene.update, {
      shinyjs::click("lawn.update")
      shinyjs::click("vol.update")
      shinyjs::click("rank.update")
    })

    #---------------sgRNA Tab-----------------

    # Load the gene summaries for easy plotting.
    set1.sgrnas <- reactive({
      df <- sgrna.data()[[input$sgrna.sel1]]
      df$Rank <- rank(df$LFC)
      df
    })

    set2.sgrnas <- reactive({
      if (length(sgrna.data()) > 1) {
        df <- sgrna.data()[[input$sgrna.sel2]]
        df$Rank <- rank(df$LFC)
        df
      }
    })

    # Summary tables and plots.
    output$sgrna1.summary <- renderDT(server = FALSE, {
      req(set1.sgrnas)

      df <- set1.sgrnas()

      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$sgrna.sel1, " sgRNA Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    output$sgrna1.counts <- renderPlotly({
      req(set1.sgrnas, input$sgrna.gene)

      df <- set1.sgrnas()
      df <- df[df$Gene == input$sgrna.gene,]

      .make_sgrna_pairplot(df)
    })

    output$sgrna1.rank <- renderPlotly({
      req(set1.sgrnas)
      input$rank.update

      df <- set1.sgrnas()

      hov.info <- c("Gene")

      highlight <- NULL
      highlight <- df$sgrna[df$Gene == input$sgrna.gene]

      .make_rank(df = df,
                 ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
                 y.thresh = 0,
                 y.lines = FALSE,
                 sig.thresh = 0,
                 h.id = h.id,
                 h.id.suffix = "_sgrank1",
                 sig.term = "FDR",
                 y.term = "LFC",
                 x.term = "Rank",
                 feat.term = "sgrna",
                 hover.info = hov.info,
                 fs = NULL,
                 up.color = "#A6A6A6",
                 down.color = "#A6A6A6",
                 insig.color = "#A6A6A6",
                 sig.opacity = 1,
                 insig.opacity = 1,
                 sig.size = 5,
                 insig.size = 5,
                 label.size = 8,
                 webgl = TRUE,
                 webgl.ratio = 7,
                 show.counts = FALSE,
                 show.hl.counts = FALSE,
                 counts.size = 8,
                 highlight.featsets = NULL,
                 highlight.feats = highlight,
                 featsets = NULL,
                 highlight.feats.color = "red",
                 highlight.feats.size = 8,
                 highlight.feats.opac = 1,
                 highlight.feats.linecolor = "black",
                 highlight.feats.linewidth = 0.5,
                 highlight.featsets.color = "#A6A6A6",
                 highlight.featsets.size = 7,
                 highlight.featsets.opac = 1,
                 highlight.featsets.linecolor = "black",
                 highlight.featsets.linewidth = 0.5)
    })

    output$sgrna1.detail <- renderDT({
      req(set1.sgrnas, input$sgrna.gene)
      
      df <- set1.sgrnas()
      df <- df[df$Gene == input$sgrna.gene,]
      
      target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1
      
      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$sgrna.sel1, " ", input$sgrna.gene, " sgRNA Details"),
                    options = list(
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    observe({
      if (length(sgrna.data()) > 1) {
        output$sgrna2.summary <- renderDT(server = FALSE, {
          req(set2.sgrnas)
  
          df <- set2.sgrnas()
  
          DT::datatable(df,
                        rownames = FALSE,
                        filter = "top",
                        extensions = c("Buttons"),
                        caption = paste0(input$sgrna.sel2, " sgRNA Summary"),
                        options = list(
                          search = list(regex = TRUE),
                          pageLength = 10,
                          dom = 'Blfrtip',
                          buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))
          ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
        })
  
        output$sgrna2.counts <- renderPlotly({
          req(set2.sgrnas, input$sgrna.gene)
  
          df <- set2.sgrnas()
          df <- df[df$Gene == input$sgrna.gene,]
  
          .make_sgrna_pairplot(df)
        })
  
        output$sgrna2.rank <- renderPlotly({
          req(set2.sgrnas)
          input$rank.update
  
          df <- set2.sgrnas()
  
          hov.info <- c("Gene")
  
          highlight <- NULL
          highlight <- df$sgrna[df$Gene == input$sgrna.gene]
  
          .make_rank(df = df,
                     ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
                     y.thresh = 0,
                     y.lines = FALSE,
                     sig.thresh = 0,
                     h.id = h.id,
                     h.id.suffix = "_sgrank1",
                     sig.term = "FDR",
                     y.term = "LFC",
                     x.term = "Rank",
                     feat.term = "sgrna",
                     hover.info = hov.info,
                     fs = NULL,
                     up.color = "#A6A6A6",
                     down.color = "#A6A6A6",
                     insig.color = "#A6A6A6",
                     sig.opacity = 1,
                     insig.opacity = 1,
                     sig.size = 5,
                     insig.size = 5,
                     label.size = 8,
                     webgl = TRUE,
                     webgl.ratio = 7,
                     show.counts = FALSE,
                     show.hl.counts = FALSE,
                     counts.size = 8,
                     highlight.featsets = NULL,
                     highlight.feats = highlight,
                     featsets = NULL,
                     highlight.feats.color = "red",
                     highlight.feats.size = 8,
                     highlight.feats.opac = 1,
                     highlight.feats.linecolor = "black",
                     highlight.feats.linewidth = 0.5,
                     highlight.featsets.color = "#A6A6A6",
                     highlight.featsets.size = 7,
                     highlight.featsets.opac = 1,
                     highlight.featsets.linecolor = "black",
                     highlight.featsets.linewidth = 0.5)
        })
  
        output$sgrna2.detail <- renderDT({
          req(set2.sgrnas, input$sgrna.gene)
  
          df <- set2.sgrnas()
          df <- df[df$Gene == input$sgrna.gene,]
  
          target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1
  
          DT::datatable(df,
                        rownames = FALSE,
                        filter = "top",
                        extensions = c("Buttons"),
                        caption = paste0(input$sgrna.sel2, " ", input$sgrna.gene, " sgRNA Details"),
                        options = list(
                          pageLength = 10,
                          dom = 'Blfrtip',
                          buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                          columnDefs = list(list(visible = FALSE, targets = target)))
          ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
        })
      }
    })

    #--------------DepMap Tab-----------------
    if (!is.null(depmap.gene)) {
      output$depmap.deplines <- renderUI({
        req(input$depmap.gene, depmap.gene)
        input$dm.dep.update

        dep.info <- get_depmap_essentiality(input$depmap.gene, depmap.gene)
        dep.release <- depmap::depmap_release()
        .make_dependency_tag(dep.info = dep.info, 
                             dep.release = dep.release, 
                             crispr.color = isolate(input$dep.crispr.color), 
                             rnai.color = isolate(input$dep.rnai.color))
      })
      
      # Dependency
      output$depmap.essplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.dep.update
        
        dep.info <- plot_depmap_dependency(gene = input$depmap.gene, 
                                           crispr.color = isolate(input$dep.crispr.color),
                                           rnai.color = isolate(input$dep.rnai.color),
                                           depline = isolate(input$dep.depline),
                                           plot.grid = isolate(input$dep.plot.grid),
                                           depmap.meta = depmap.meta, 
                                           depmap.pool = pool)
      })
      
      # Expression
      output$depmap.expplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.exp.update
        
        dep.info <- plot_depmap_expression(gene = input$depmap.gene, 
                                           depmap.meta = depmap.meta, 
                                           depmap.pool = pool,
                                           color = isolate(input$exp.color),
                                           plot.grid = isolate(input$exp.plot.grid))
      })
      
      # Copy number
      output$depmap.cnplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.cn.update
        
        dep.info <- plot_depmap_cn(gene = input$depmap.gene, 
                                   depmap.meta = depmap.meta, 
                                   depmap.pool = pool,
                                   color = isolate(input$cn.color),
                                   plot.grid = isolate(input$cn.plot.grid))
      })
      
      # Lineage plot
      output$depmap.lineages <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.lineage.update

        dep.info <- plot_depmap_lineages(gene = input$depmap.gene, 
                                         data.type = isolate(input$lin.data),
                                         group.by = isolate(input$lin.group),
                                         label.size = isolate(input$lin.label.size),
                                         pt.color = isolate(input$lin.pt.color),
                                         pt.size = isolate(input$lin.pt.size),
                                         boxplot.fill = isolate(input$lin.box.fill),
                                         boxplot.line.color = isolate(input$lin.box.color),
                                         depline = isolate(input$lin.depline),
                                         depmap.meta = depmap.meta, 
                                         depmap.pool = pool)
      })

      # Sublineage plot
      output$depmap.sublineage <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        input$dm.sublineage.update

        dep.info <- plot_depmap_lineages(gene = input$depmap.gene, 
                                         data.type = isolate(input$lin.data),
                                         group.by = "lineage_subtype",
                                         lineage = isolate(input$sub.lineage),
                                         label.size = isolate(input$sub.label.size),
                                         pt.color = isolate(input$sub.pt.color),
                                         pt.size = isolate(input$sub.pt.size),
                                         boxplot.fill = isolate(input$sub.box.fill),
                                         boxplot.line.color = isolate(input$sub.box.color),
                                         depline = isolate(input$sub.depline),
                                         depmap.meta = depmap.meta, 
                                         depmap.pool = pool)
      })

      # Gene info
      output$depmap.geneinfo <- renderUI({
        req(input$depmap.gene, depmap.gene)

        .make_gene_tag(input$depmap.gene)
      })
    }
  }

  if (return.app) {
    shinyApp(ui, server)
  } else {
    return(list(ui = ui, server = server))
  }
}
